use itertools::Itertools;
use std::cmp::max;

static INPUT: &str = "[[[3,[8,6]],[6,1]],[[[1,1],2],[[1,0],0]]]\n[[[1,[7,3]],1],9]\n[[[2,6],[[3,1],[0,9]]],[[7,[4,8]],[[2,7],3]]]\n[[[3,[0,4]],[[8,4],[1,9]]],[7,[2,[5,7]]]]\n[[[4,5],[[0,7],1]],[9,[0,4]]]\n[[5,[[1,5],[3,6]]],8]\n[[3,[[9,3],9]],9]\n[2,[[[2,1],[0,5]],[9,9]]]\n[[2,[6,9]],[[[4,1],0],[3,4]]]\n[[[[6,8],0],[[8,8],9]],[[[4,2],3],[3,[7,3]]]]\n[[3,7],9]\n[[[[2,5],8],[2,5]],[[0,[5,7]],[[2,5],4]]]\n[[[8,[6,6]],0],[4,[[5,6],[8,4]]]]\n[[[1,[8,2]],[[0,4],[2,6]]],[[3,4],0]]\n[[1,[[9,2],[6,0]]],[[[0,9],5],[[8,0],[1,5]]]]\n[[2,[[2,3],[1,8]]],[3,[[7,2],[0,7]]]]\n[[5,4],5]\n[[[[4,2],[4,8]],[7,3]],[0,[[8,9],6]]]\n[[[6,7],0],5]\n[[2,[[9,0],[8,4]]],[[[7,4],[3,4]],0]]\n[[[9,[8,9]],1],[[5,[6,7]],3]]\n[[2,[0,0]],[3,[[2,5],[1,4]]]]\n[[0,1],[0,[[8,8],[8,3]]]]\n[[[0,2],[2,8]],[1,[[7,0],0]]]\n[[[[5,4],3],[[7,5],[2,6]]],[[5,8],[0,1]]]\n[0,[0,0]]\n[[5,[[5,6],0]],[[[2,7],9],[7,9]]]\n[[[[0,8],2],[[2,5],[7,6]]],[[9,7],[[8,7],[9,2]]]]\n[[[0,[4,6]],[[6,3],[4,4]]],[8,[[4,8],[4,8]]]]\n[[[[8,9],[3,8]],8],[[[7,9],6],[9,[2,7]]]]\n[[[[8,9],[1,6]],0],[[[8,7],4],[9,[1,4]]]]\n[5,7]\n[[[[1,5],[3,6]],[[5,5],4]],[[3,3],[4,[4,0]]]]\n[[[0,6],[5,[5,3]]],[[4,[0,0]],8]]\n[7,[6,8]]\n[[[[8,5],9],[[3,2],7]],[[[6,6],5],2]]\n[[[[4,4],[0,4]],9],0]\n[[0,[3,[9,3]]],[9,[[8,0],[0,9]]]]\n[[[[4,0],0],[1,[1,7]]],[[3,[3,0]],[[1,3],6]]]\n[[9,4],[3,[[7,1],6]]]\n[[[[3,7],7],1],[[4,3],[[6,9],[6,9]]]]\n[[[8,[2,5]],[[8,4],4]],[[[3,4],[6,7]],[5,[8,5]]]]\n[2,[4,[[3,2],7]]]\n[[[[3,1],[5,6]],[[2,7],7]],[4,[8,[7,4]]]]\n[[7,8],[[[3,9],7],2]]\n[[[[8,8],[5,8]],[[1,0],[6,0]]],[[[1,2],6],[[4,2],[5,5]]]]\n[[1,[0,9]],[[[2,1],1],1]]\n[[6,[8,1]],[4,[[7,8],5]]]\n[[[1,[1,6]],[1,[5,7]]],[[[2,8],6],0]]\n[9,1]\n[[[0,[6,5]],[[8,5],2]],[[[2,4],[7,3]],[[1,5],[9,2]]]]\n[[[2,7],[0,[3,6]]],[[[1,0],[9,6]],[1,[0,4]]]]\n[6,[[[5,9],8],[0,2]]]\n[7,[[[9,4],[8,6]],[[1,1],1]]]\n[[[2,1],0],8]\n[1,[[6,[1,4]],[[0,0],[1,9]]]]\n[[[1,[7,9]],2],8]\n[[[[0,9],2],[[8,4],9]],[0,[[7,7],[4,8]]]]\n[[1,[2,[1,8]]],[[[3,6],[2,1]],[3,[5,0]]]]\n[[3,3],[3,5]]\n[[[[9,3],[4,3]],[5,[8,1]]],[[6,[5,0]],9]]\n[0,[[9,[3,5]],3]]\n[[[9,1],0],[[[5,9],[8,0]],[7,[4,8]]]]\n[[[[7,7],8],3],[[[6,6],[6,5]],[6,4]]]\n[[[[3,7],1],[9,[4,2]]],[[9,[2,5]],[[9,0],5]]]\n[5,[[0,2],6]]\n[[[[2,7],[5,3]],[1,8]],2]\n[[[8,[7,7]],[9,[0,0]]],4]\n[[[4,[1,4]],0],[[[8,7],8],[[4,1],7]]]\n[[[[0,6],0],[[3,2],[9,8]]],[[9,[4,5]],[[7,7],[0,8]]]]\n[[[[6,3],3],[[1,5],7]],[[0,1],[7,7]]]\n[[[[2,0],2],[3,[3,5]]],[[[0,8],[8,2]],[[0,6],5]]]\n[[[6,[5,3]],[[5,5],9]],[[5,9],[[8,7],[3,7]]]]\n[[[[1,7],[3,4]],[9,2]],1]\n[[[[8,2],6],1],[[5,[2,7]],[3,9]]]\n[5,[5,7]]\n[[[[9,8],[3,4]],[[2,5],[5,6]]],[[[2,7],7],[9,[8,7]]]]\n[[[1,4],[[6,1],[1,3]]],[1,[7,[1,7]]]]\n[[[[1,4],8],[[5,1],8]],[[[1,3],[6,9]],[6,[3,3]]]]\n[[[[4,0],[0,7]],[4,5]],[4,2]]\n[3,8]\n[7,[[[7,6],5],[[6,6],5]]]\n[[[5,[0,5]],[4,4]],[3,[[4,2],[7,0]]]]\n[[[[7,9],8],[9,6]],[5,0]]\n[[[[3,0],[5,2]],1],[[[6,9],[5,3]],[[2,5],[6,3]]]]\n[7,[[[7,7],[4,5]],[9,2]]]\n[[7,[[4,2],[9,3]]],[7,[6,1]]]\n[7,9]\n[[[8,[8,1]],[[7,3],1]],[[9,8],[2,[8,3]]]]\n[[[9,3],3],3]\n[[[8,[5,7]],[[2,1],[1,3]]],[[[3,5],2],0]]\n[[[8,8],0],[[1,4],[[8,6],9]]]\n[[9,[3,[3,0]]],[1,7]]\n[1,[[[8,8],1],[2,[0,5]]]]\n[[0,[1,5]],[9,[0,[9,0]]]]\n[1,[[[1,1],[8,3]],[1,8]]]\n[[5,[[7,7],[3,3]]],[[[6,6],[7,8]],[1,[0,0]]]]\n[[[[6,7],1],[0,2]],[[[4,2],[7,6]],[[8,4],[4,9]]]]\n[[6,[[3,3],[9,0]]],[1,[[4,5],4]]]\n[[[[3,4],7],[9,0]],[[[4,5],1],[[5,1],[9,3]]]]";

#[derive(Debug, Clone)]
enum Element {
  Val(i32),
  Arr(Box<Element>,Box<Element>),
}

fn parse_element(s: &[u8], i: usize) -> (usize, Element) {
  match s[i] {
    b'[' => {
      let (i, e1) = parse_element(s, i+1);
      let (i, e2) = parse_element(s, i+1);
      (i+1, Element::Arr(Box::new(e1), Box::new(e2)))
    }
    _ => (i+1, Element::Val((s[i] - b'0') as i32))
  }
}

fn split(e: &Element) -> Option<Element> {
  match &e {
    Element::Val(x) if *x >= 10 => {
      let a = *x / 2;
      let b = *x - a;
      return Some(Element::Arr(Box::new(Element::Val(a)), Box::new(Element::Val(b))));
    }
    Element::Arr(e1, e2) => {
      if let Some(a) = split(e1) {
        return Some(Element::Arr(Box::new(a), e2.clone()));
      }
      if let Some(b) = split(e2) {
        return Some(Element::Arr(e1.clone(), Box::new(b)));
      }
    }
    _ => {}
  }
  None
}

fn add_left(e: &Element, e2: &Option<Element>) -> Element {
  match (e, e2) {
    (_, None) => e.clone(),
    (Element::Val(x), Some(Element::Val(x2))) => Element::Val(*x + x2),
    (Element::Arr(a,b), _) => Element::Arr(Box::new(add_left(a, e2)), b.clone()),
    _ => panic!()
  }
}

fn add_right(e: &Element, e2: &Option<Element>) -> Element {
  match (e, e2) {
    (_, None) => e.clone(),
    (Element::Val(x), Some(Element::Val(x2))) => Element::Val(*x + x2),
    (Element::Arr(a,b), _) => Element::Arr(a.clone(), Box::new(add_right(b, e2))),
    _ => panic!()
  }
}

fn depth(e: &Element) -> usize {
  match e {
    Element::Val(_) => 0,
    Element::Arr(e1,e2) => 1 + max(depth(e1), depth(e2)),
  }
}

fn explode(e: &Element, n: usize) -> Option<(Option<Element>, Element, Option<Element>)> {
  if let Element::Arr(e1,e2) = e {
    if n == 1 {
      return Some((Some(*e1.clone()), Element::Val(0), Some(*e2.clone())));
    }
    if let Some((left, a, right)) = explode(e1, n-1) {
      return Some((left, Element::Arr(Box::new(a), Box::new(add_left(e2, &right))), None));
    }
    if let Some((left, b, right)) = explode(e2, n-1) {
      return Some((None, Element::Arr(Box::new(add_right(&e1, &left)), Box::new(b)), right));
    }
  }
  None
}

fn reduce(mut e: Element) -> Element {
  loop {
    let d = depth(&e);
    if d > 4 {
      if let Some((_,e2,_)) = explode(&e, d) {
        e = e2;
        continue;
      }
    }
    if let Some(e2) = split(&e) {
      e = e2;
    } else {
      break e;
    }
  }
}

fn add(e1: &Element, e2: &Element) -> Element {
  reduce(Element::Arr(Box::new(e1.clone()), Box::new(e2.clone())))
}

fn magnitude(e: Element) -> i32 {
  match e {
    Element::Val(x) => x,
    Element::Arr(e1,e2) => 3 * magnitude(*e1) + 2 * magnitude(*e2)
  }
}

aoc2021::main! {
  let elements = INPUT.lines()
    .map(|l| parse_element(l.as_bytes(), 0).1)
    .collect::<Vec<_>>();
  let p1 = magnitude(elements[1..].iter().fold(elements[0].clone(), |e1,e2| add(&e1,e2)));
  let p2 = elements.iter()
    .tuple_combinations()
    .map(|(e1,e2)| max(magnitude(add(e1,e2)), magnitude(add(e2,e1))))
    .max()
    .unwrap();
  (p1,p2)
}
