use std::cmp::max;
use itertools::Itertools;

static INPUT: &str = "[[[3,[8,6]],[6,1]],[[[1,1],2],[[1,0],0]]]\n[[[1,[7,3]],1],9]\n[[[2,6],[[3,1],[0,9]]],[[7,[4,8]],[[2,7],3]]]\n[[[3,[0,4]],[[8,4],[1,9]]],[7,[2,[5,7]]]]\n[[[4,5],[[0,7],1]],[9,[0,4]]]\n[[5,[[1,5],[3,6]]],8]\n[[3,[[9,3],9]],9]\n[2,[[[2,1],[0,5]],[9,9]]]\n[[2,[6,9]],[[[4,1],0],[3,4]]]\n[[[[6,8],0],[[8,8],9]],[[[4,2],3],[3,[7,3]]]]\n[[3,7],9]\n[[[[2,5],8],[2,5]],[[0,[5,7]],[[2,5],4]]]\n[[[8,[6,6]],0],[4,[[5,6],[8,4]]]]\n[[[1,[8,2]],[[0,4],[2,6]]],[[3,4],0]]\n[[1,[[9,2],[6,0]]],[[[0,9],5],[[8,0],[1,5]]]]\n[[2,[[2,3],[1,8]]],[3,[[7,2],[0,7]]]]\n[[5,4],5]\n[[[[4,2],[4,8]],[7,3]],[0,[[8,9],6]]]\n[[[6,7],0],5]\n[[2,[[9,0],[8,4]]],[[[7,4],[3,4]],0]]\n[[[9,[8,9]],1],[[5,[6,7]],3]]\n[[2,[0,0]],[3,[[2,5],[1,4]]]]\n[[0,1],[0,[[8,8],[8,3]]]]\n[[[0,2],[2,8]],[1,[[7,0],0]]]\n[[[[5,4],3],[[7,5],[2,6]]],[[5,8],[0,1]]]\n[0,[0,0]]\n[[5,[[5,6],0]],[[[2,7],9],[7,9]]]\n[[[[0,8],2],[[2,5],[7,6]]],[[9,7],[[8,7],[9,2]]]]\n[[[0,[4,6]],[[6,3],[4,4]]],[8,[[4,8],[4,8]]]]\n[[[[8,9],[3,8]],8],[[[7,9],6],[9,[2,7]]]]\n[[[[8,9],[1,6]],0],[[[8,7],4],[9,[1,4]]]]\n[5,7]\n[[[[1,5],[3,6]],[[5,5],4]],[[3,3],[4,[4,0]]]]\n[[[0,6],[5,[5,3]]],[[4,[0,0]],8]]\n[7,[6,8]]\n[[[[8,5],9],[[3,2],7]],[[[6,6],5],2]]\n[[[[4,4],[0,4]],9],0]\n[[0,[3,[9,3]]],[9,[[8,0],[0,9]]]]\n[[[[4,0],0],[1,[1,7]]],[[3,[3,0]],[[1,3],6]]]\n[[9,4],[3,[[7,1],6]]]\n[[[[3,7],7],1],[[4,3],[[6,9],[6,9]]]]\n[[[8,[2,5]],[[8,4],4]],[[[3,4],[6,7]],[5,[8,5]]]]\n[2,[4,[[3,2],7]]]\n[[[[3,1],[5,6]],[[2,7],7]],[4,[8,[7,4]]]]\n[[7,8],[[[3,9],7],2]]\n[[[[8,8],[5,8]],[[1,0],[6,0]]],[[[1,2],6],[[4,2],[5,5]]]]\n[[1,[0,9]],[[[2,1],1],1]]\n[[6,[8,1]],[4,[[7,8],5]]]\n[[[1,[1,6]],[1,[5,7]]],[[[2,8],6],0]]\n[9,1]\n[[[0,[6,5]],[[8,5],2]],[[[2,4],[7,3]],[[1,5],[9,2]]]]\n[[[2,7],[0,[3,6]]],[[[1,0],[9,6]],[1,[0,4]]]]\n[6,[[[5,9],8],[0,2]]]\n[7,[[[9,4],[8,6]],[[1,1],1]]]\n[[[2,1],0],8]\n[1,[[6,[1,4]],[[0,0],[1,9]]]]\n[[[1,[7,9]],2],8]\n[[[[0,9],2],[[8,4],9]],[0,[[7,7],[4,8]]]]\n[[1,[2,[1,8]]],[[[3,6],[2,1]],[3,[5,0]]]]\n[[3,3],[3,5]]\n[[[[9,3],[4,3]],[5,[8,1]]],[[6,[5,0]],9]]\n[0,[[9,[3,5]],3]]\n[[[9,1],0],[[[5,9],[8,0]],[7,[4,8]]]]\n[[[[7,7],8],3],[[[6,6],[6,5]],[6,4]]]\n[[[[3,7],1],[9,[4,2]]],[[9,[2,5]],[[9,0],5]]]\n[5,[[0,2],6]]\n[[[[2,7],[5,3]],[1,8]],2]\n[[[8,[7,7]],[9,[0,0]]],4]\n[[[4,[1,4]],0],[[[8,7],8],[[4,1],7]]]\n[[[[0,6],0],[[3,2],[9,8]]],[[9,[4,5]],[[7,7],[0,8]]]]\n[[[[6,3],3],[[1,5],7]],[[0,1],[7,7]]]\n[[[[2,0],2],[3,[3,5]]],[[[0,8],[8,2]],[[0,6],5]]]\n[[[6,[5,3]],[[5,5],9]],[[5,9],[[8,7],[3,7]]]]\n[[[[1,7],[3,4]],[9,2]],1]\n[[[[8,2],6],1],[[5,[2,7]],[3,9]]]\n[5,[5,7]]\n[[[[9,8],[3,4]],[[2,5],[5,6]]],[[[2,7],7],[9,[8,7]]]]\n[[[1,4],[[6,1],[1,3]]],[1,[7,[1,7]]]]\n[[[[1,4],8],[[5,1],8]],[[[1,3],[6,9]],[6,[3,3]]]]\n[[[[4,0],[0,7]],[4,5]],[4,2]]\n[3,8]\n[7,[[[7,6],5],[[6,6],5]]]\n[[[5,[0,5]],[4,4]],[3,[[4,2],[7,0]]]]\n[[[[7,9],8],[9,6]],[5,0]]\n[[[[3,0],[5,2]],1],[[[6,9],[5,3]],[[2,5],[6,3]]]]\n[7,[[[7,7],[4,5]],[9,2]]]\n[[7,[[4,2],[9,3]]],[7,[6,1]]]\n[7,9]\n[[[8,[8,1]],[[7,3],1]],[[9,8],[2,[8,3]]]]\n[[[9,3],3],3]\n[[[8,[5,7]],[[2,1],[1,3]]],[[[3,5],2],0]]\n[[[8,8],0],[[1,4],[[8,6],9]]]\n[[9,[3,[3,0]]],[1,7]]\n[1,[[[8,8],1],[2,[0,5]]]]\n[[0,[1,5]],[9,[0,[9,0]]]]\n[1,[[[1,1],[8,3]],[1,8]]]\n[[5,[[7,7],[3,3]]],[[[6,6],[7,8]],[1,[0,0]]]]\n[[[[6,7],1],[0,2]],[[[4,2],[7,6]],[[8,4],[4,9]]]]\n[[6,[[3,3],[9,0]]],[1,[[4,5],4]]]\n[[[[3,4],7],[9,0]],[[[4,5],1],[[5,1],[9,3]]]]";

#[derive(Clone)]
enum Element {
  Val(i32),
  Pair(Box<Element>,Box<Element>),
}

impl Element {
  fn parse(s: &[u8], i: usize) -> (usize, Self) {
    match s[i] {
      b'[' => {
        let (i, e1) = Self::parse(s, i+1);
        let (i, e2) = Self::parse(s, i+1);
        (i+1, Self::Pair(e1.boxed(), e2.boxed()))
      }
      _ => (i+1, Self::Val((s[i] - b'0') as i32))
    }
  }

  fn boxed(self) -> Box<Self> { Box::new(self) }

  fn depth(&self) -> usize {
    match self {
      Self::Val(_) => 0,
      Self::Pair(e1,e2) => 1 + max(e1.depth(), e2.depth()),
    }
  }

  fn magnitude(&self) -> i32 {
    match self {
      Self::Val(x) => *x,
      Self::Pair(e1,e2) => 3 * e1.magnitude() + 2 * e2.magnitude()
    }
  }

  fn split(&self) -> Option<Self> {
    match self {
      Self::Val(x) if *x >= 10 => {
        let a = *x / 2;
        let b = *x - a;
        return Some(Self::Pair(Self::Val(a).boxed(), Self::Val(b).boxed()));
      }
      Self::Pair(e1, e2) => {
        if let Some(a) = e1.split() {
          return Some(Self::Pair(a.boxed(), e2.clone()));
        }
        if let Some(b) = e2.split() {
          return Some(Self::Pair(e1.clone(), b.boxed()));
        }
      }
      _ => {}
    }
    None
  }

  fn add_left(&self, e2: Option<Self>) -> Self {
    match (self, e2) {
      (_, None) => self.clone(),
      (Self::Val(x), Some(Self::Val(x2))) => Self::Val(*x + x2),
      (Self::Pair(a,b), e2) => Self::Pair(a.add_left(e2).boxed(), b.clone()),
      _ => panic!()
    }
  }

  fn add_right(&self, e2: Option<Self>) -> Self {
    match (self, e2) {
      (_, None) => self.clone(),
      (Self::Val(x), Some(Self::Val(x2))) => Self::Val(*x + x2),
      (Self::Pair(a,b), e2) => Self::Pair(a.clone(), b.add_right(e2).boxed()),
      _ => panic!()
    }
  }

  fn explode(&self, n: usize) -> Option<(Option<Self>, Self, Option<Self>)> {
    if let Self::Pair(e1,e2) = self {
      if n == 1 {
        return Some((Some(*e1.clone()), Self::Val(0), Some(*e2.clone())));
      }
      if let Some((left, a, right)) = e1.explode(n-1) {
        let e = Self::Pair(a.boxed(), e2.add_left(right).boxed());
        return Some((left, e, None));
      }
      if let Some((left, b, right)) = e2.explode(n-1) {
        let e = Self::Pair(e1.add_right(left).boxed(), b.boxed());
        return Some((None, e, right));
      }
    }
    None
  }

  fn reduce(mut self) -> Self {
    loop {
      let d = self.depth();
      if d > 4 {
        if let Some((_,e2,_)) = self.explode(d) {
          self = e2;
          continue;
        }
      }
      match self.split() {
        Some(e2) => self = e2,
        None => break self,
      }
    }
  }
}

fn add(e1: &Element, e2: &Element) -> Element {
  Element::Pair(e1.clone().boxed(), e2.clone().boxed()).reduce()
}

aoc2021::main! {
  let elements = INPUT.lines()
    .map(|l| Element::parse(l.as_bytes(), 0).1)
    .collect::<Vec<_>>();
  let p1 = elements[1..].iter()
    .fold(elements[0].clone(), |e1,e2| add(&e1,e2))
    .magnitude();
  let p2 = elements.iter()
    .tuple_combinations()
    .flat_map(|(e1,e2)| [add(e1,e2).magnitude(), add(e2,e1).magnitude()])
    .max()
    .unwrap();
  (p1,p2)
}
